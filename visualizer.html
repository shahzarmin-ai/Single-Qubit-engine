<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Quantum State Mapper</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Syne:wght@400;600;700;800&display=swap');

  :root {
    --bg: #04060f;
    --surface: #080d1e;
    --surface2: #0d1630;
    --border: #1a2845;
    --accent: #00e5ff;
    --accent2: #7b2fff;
    --accent3: #ff2d6d;
    --gold: #ffd166;
    --text: #c8d8f0;
    --text-dim: #5a7099;
    --pure: #00ff88;
    --mixed: #ff6b35;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Space Mono', monospace;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* starfield */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image:
      radial-gradient(1px 1px at 10% 20%, rgba(0,229,255,0.3) 0%, transparent 100%),
      radial-gradient(1px 1px at 30% 70%, rgba(123,47,255,0.3) 0%, transparent 100%),
      radial-gradient(1px 1px at 60% 10%, rgba(0,229,255,0.2) 0%, transparent 100%),
      radial-gradient(1px 1px at 80% 50%, rgba(123,47,255,0.2) 0%, transparent 100%),
      radial-gradient(1px 1px at 50% 90%, rgba(0,255,136,0.2) 0%, transparent 100%),
      radial-gradient(1px 1px at 95% 80%, rgba(0,229,255,0.15) 0%, transparent 100%);
    pointer-events: none;
    z-index: 0;
  }

  header {
    position: relative;
    z-index: 1;
    padding: 2rem 3rem 1.5rem;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 2rem;
    background: linear-gradient(180deg, rgba(0,229,255,0.04) 0%, transparent 100%);
  }

  .logo {
    width: 48px; height: 48px;
    position: relative;
    flex-shrink: 0;
  }

  .logo svg { width: 100%; height: 100%; }

  header h1 {
    font-family: 'Syne', sans-serif;
    font-size: 1.5rem;
    font-weight: 800;
    letter-spacing: -0.02em;
    color: #fff;
  }

  header h1 span { color: var(--accent); }

  .header-sub {
    font-size: 0.7rem;
    color: var(--text-dim);
    letter-spacing: 0.1em;
    text-transform: uppercase;
  }

  .main-grid {
    position: relative;
    z-index: 1;
    display: grid;
    grid-template-columns: 320px 1fr 300px;
    grid-template-rows: auto 1fr;
    height: calc(100vh - 90px);
    overflow: hidden;
  }

  /* ── Left Panel ── */
  .panel-left {
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    padding: 1.5rem;
    gap: 1.5rem;
  }

  .section-label {
    font-size: 0.62rem;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--accent);
    margin-bottom: 0.75rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .section-label::after {
    content: '';
    flex: 1;
    height: 1px;
    background: linear-gradient(90deg, var(--border), transparent);
  }

  /* State init */
  .init-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.5rem;
  }

  .state-btn {
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    font-family: 'Space Mono', monospace;
    font-size: 0.75rem;
    padding: 0.5rem;
    cursor: pointer;
    transition: all 0.15s;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.2rem;
  }

  .state-btn:hover, .state-btn.active {
    border-color: var(--accent);
    background: rgba(0,229,255,0.08);
    color: var(--accent);
  }

  .state-btn .ket { font-size: 0.95rem; font-weight: 700; }
  .state-btn .desc { font-size: 0.6rem; color: var(--text-dim); }

  /* Bloch angle inputs */
  .angle-row {
    display: flex;
    flex-direction: column;
    gap: 0.6rem;
  }

  .angle-item label {
    display: flex;
    justify-content: space-between;
    font-size: 0.7rem;
    color: var(--text-dim);
    margin-bottom: 0.3rem;
  }

  .angle-item label span { color: var(--accent); }

  input[type=range] {
    width: 100%;
    -webkit-appearance: none;
    height: 3px;
    background: var(--border);
    outline: none;
  }

  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 12px; height: 12px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    box-shadow: 0 0 8px var(--accent);
  }

  /* Gates */
  .gate-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 0.4rem;
  }

  .gate-btn {
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    font-family: 'Space Mono', monospace;
    font-size: 0.8rem;
    font-weight: 700;
    padding: 0.55rem 0;
    cursor: pointer;
    transition: all 0.12s;
    text-align: center;
  }

  .gate-btn:hover { border-color: var(--accent2); color: var(--accent2); background: rgba(123,47,255,0.1); }
  .gate-btn.x-gate:hover { border-color: var(--accent3); color: var(--accent3); background: rgba(255,45,109,0.1); }
  .gate-btn.h-gate:hover { border-color: var(--gold); color: var(--gold); background: rgba(255,209,102,0.1); }
  .gate-btn.special:hover { border-color: var(--pure); color: var(--pure); background: rgba(0,255,136,0.1); }

  .rotation-row {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 0.4rem;
    align-items: center;
  }

  .rotation-row select {
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    font-family: 'Space Mono', monospace;
    font-size: 0.75rem;
    padding: 0.4rem;
    outline: none;
    cursor: pointer;
  }

  .rotation-row button {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--accent);
    font-family: 'Space Mono', monospace;
    font-size: 0.7rem;
    padding: 0.4rem 0.7rem;
    cursor: pointer;
    transition: all 0.12s;
    white-space: nowrap;
  }

  .rotation-row button:hover { border-color: var(--accent); background: rgba(0,229,255,0.1); }

  /* Noise */
  .noise-section select {
    width: 100%;
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    font-family: 'Space Mono', monospace;
    font-size: 0.72rem;
    padding: 0.45rem;
    outline: none;
    cursor: pointer;
    margin-bottom: 0.6rem;
  }

  .noise-section button {
    width: 100%;
    background: rgba(255,45,109,0.08);
    border: 1px solid rgba(255,45,109,0.3);
    color: var(--accent3);
    font-family: 'Space Mono', monospace;
    font-size: 0.72rem;
    padding: 0.45rem;
    cursor: pointer;
    transition: all 0.12s;
    margin-top: 0.4rem;
  }

  .noise-section button:hover { background: rgba(255,45,109,0.15); border-color: var(--accent3); }

  /* actions */
  .action-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.5rem;
  }

  .action-btn {
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    font-family: 'Space Mono', monospace;
    font-size: 0.7rem;
    padding: 0.55rem;
    cursor: pointer;
    transition: all 0.12s;
    text-align: center;
  }

  .action-btn.measure {
    background: rgba(255,209,102,0.08);
    border-color: rgba(255,209,102,0.3);
    color: var(--gold);
  }

  .action-btn.measure:hover { background: rgba(255,209,102,0.15); border-color: var(--gold); }
  .action-btn.reset:hover { border-color: var(--accent3); color: var(--accent3); background: rgba(255,45,109,0.08); }

  /* ── Center (Bloch Sphere Canvas) ── */
  .panel-center {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
    background: radial-gradient(ellipse 60% 60% at 50% 50%, rgba(0,229,255,0.04) 0%, transparent 70%);
  }

  #bloch-canvas {
    width: 420px;
    height: 420px;
    cursor: grab;
  }

  #bloch-canvas:active { cursor: grabbing; }

  .measurement-flash {
    position: absolute;
    inset: 0;
    background: rgba(255,209,102,0.15);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.05s;
  }

  .measurement-flash.active { opacity: 1; }

  .state-display {
    position: absolute;
    bottom: 1.5rem;
    font-size: 0.8rem;
    color: var(--text-dim);
    text-align: center;
    letter-spacing: 0.05em;
  }

  .state-display .ket-display {
    font-size: 1rem;
    color: var(--accent);
    font-weight: 700;
    margin-bottom: 0.3rem;
  }

  /* ── Right Panel ── */
  .panel-right {
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    padding: 1.5rem;
    gap: 1.5rem;
  }

  /* State card */
  .state-card {
    background: var(--surface);
    border: 1px solid var(--border);
    padding: 1rem;
  }

  .state-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.3rem 0;
    font-size: 0.72rem;
    border-bottom: 1px solid rgba(255,255,255,0.04);
  }

  .state-row:last-child { border-bottom: none; }
  .state-row .label { color: var(--text-dim); }
  .state-row .value { color: var(--text); font-weight: 700; }
  .state-row .value.good { color: var(--pure); }
  .state-row .value.warn { color: var(--mixed); }

  /* Probability bars */
  .prob-bars {
    display: flex;
    flex-direction: column;
    gap: 0.6rem;
  }

  .prob-bar-item {}
  .prob-bar-label {
    display: flex;
    justify-content: space-between;
    font-size: 0.68rem;
    color: var(--text-dim);
    margin-bottom: 0.3rem;
  }

  .prob-bar-track {
    height: 8px;
    background: var(--surface2);
    border: 1px solid var(--border);
    overflow: hidden;
  }

  .prob-bar-fill {
    height: 100%;
    transition: width 0.35s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .prob-bar-fill.zero { background: linear-gradient(90deg, var(--accent), rgba(0,229,255,0.4)); }
  .prob-bar-fill.one { background: linear-gradient(90deg, var(--accent2), rgba(123,47,255,0.4)); }

  /* Bloch vector display */
  .bloch-readout {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 0.5rem;
  }

  .bloch-axis {
    background: var(--surface);
    border: 1px solid var(--border);
    padding: 0.6rem 0.4rem;
    text-align: center;
  }

  .bloch-axis .axis-label {
    font-size: 0.6rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-bottom: 0.3rem;
  }

  .bloch-axis .axis-val {
    font-size: 0.9rem;
    font-weight: 700;
  }

  .bloch-axis.ax-x .axis-val { color: var(--accent3); }
  .bloch-axis.ax-y .axis-val { color: var(--pure); }
  .bloch-axis.ax-z .axis-val { color: var(--accent); }

  /* History */
  .history-list {
    display: flex;
    flex-direction: column;
    gap: 0.3rem;
    max-height: 200px;
    overflow-y: auto;
  }

  .history-entry {
    display: flex;
    align-items: center;
    gap: 0.6rem;
    font-size: 0.65rem;
    color: var(--text-dim);
    padding: 0.3rem 0.5rem;
    border-left: 2px solid var(--border);
    opacity: 0;
    animation: slideIn 0.2s forwards;
  }

  @keyframes slideIn {
    from { opacity: 0; transform: translateX(-8px); }
    to { opacity: 1; transform: translateX(0); }
  }

  .history-entry .op {
    color: var(--accent);
    font-weight: 700;
    min-width: 55px;
  }

  .history-entry.measure-entry { border-left-color: var(--gold); }
  .history-entry.measure-entry .op { color: var(--gold); }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 4px; }
  ::-webkit-scrollbar-track { background: var(--bg); }
  ::-webkit-scrollbar-thumb { background: var(--border); }

  /* Purity indicator */
  .purity-ring {
    position: relative;
    width: 60px; height: 60px;
    margin: 0 auto;
  }

  .last-measure-box {
    background: rgba(255,209,102,0.06);
    border: 1px solid rgba(255,209,102,0.2);
    padding: 0.6rem;
    text-align: center;
    font-size: 0.7rem;
    color: var(--gold);
    display: none;
  }

  .last-measure-box.show { display: block; }
  .last-measure-box .outcome { font-size: 1.8rem; font-weight: 700; }
</style>
</head>
<body>

<header>
  <div class="logo">
    <svg viewBox="0 0 48 48" fill="none">
      <circle cx="24" cy="24" r="20" stroke="#00e5ff" stroke-width="1" stroke-dasharray="4 2" opacity="0.4"/>
      <circle cx="24" cy="24" r="20" stroke="#00e5ff" stroke-width="1" stroke-dasharray="4 2" transform="rotate(90 24 24)" opacity="0.2"/>
      <ellipse cx="24" cy="24" rx="20" ry="7" stroke="#7b2fff" stroke-width="1" opacity="0.4"/>
      <line x1="24" y1="4" x2="24" y2="44" stroke="#1a2845" stroke-width="1"/>
      <line x1="4" y1="24" x2="44" y2="24" stroke="#1a2845" stroke-width="1"/>
      <circle cx="24" cy="24" r="3" fill="#00e5ff" opacity="0.6"/>
      <line id="header-arrow" x1="24" y1="24" x2="24" y2="8" stroke="#00e5ff" stroke-width="2" marker-end="url(#ah)"/>
      <defs>
        <marker id="ah" markerWidth="6" markerHeight="6" refX="3" refY="3" orient="auto">
          <path d="M 0 0 L 6 3 L 0 6 z" fill="#00e5ff"/>
        </marker>
      </defs>
    </svg>
  </div>
  <div>
    <h1>Quantum <span>State</span> Mapper</h1>
    <div class="header-sub">Single-qubit simulator · Bloch sphere · Density matrix · Noise channels</div>
  </div>
</header>

<div class="main-grid">
  <!-- LEFT -->
  <div class="panel-left">
    <div>
      <div class="section-label">Initial State</div>
      <div class="init-grid">
        <button class="state-btn active" onclick="setPreset(1,0,'|0⟩')">
          <span class="ket">|0⟩</span>
          <span class="desc">North pole</span>
        </button>
        <button class="state-btn" onclick="setPreset(0,1,'|1⟩')">
          <span class="ket">|1⟩</span>
          <span class="desc">South pole</span>
        </button>
        <button class="state-btn" onclick="setPreset(0.707,0.707,'|+⟩')">
          <span class="ket">|+⟩</span>
          <span class="desc">X+ eigenstate</span>
        </button>
        <button class="state-btn" onclick="setPreset(0.707,-0.707,'|-⟩')">
          <span class="ket">|-⟩</span>
          <span class="desc">X- eigenstate</span>
        </button>
        <button class="state-btn" onclick="setPreset(0.707, {im:0.707},'|i+⟩')">
          <span class="ket">|i⟩</span>
          <span class="desc">Y+ eigenstate</span>
        </button>
        <button class="state-btn" onclick="setPreset(0.707, {im:-0.707},'|-i⟩')">
          <span class="ket">|-i⟩</span>
          <span class="desc">Y- eigenstate</span>
        </button>
      </div>
    </div>

    <div>
      <div class="section-label">Bloch Angles</div>
      <div class="angle-row">
        <div class="angle-item">
          <label>θ (polar) <span id="theta-val">0.00°</span></label>
          <input type="range" id="theta-slider" min="0" max="180" value="0" step="0.5" oninput="onAngleChange()">
        </div>
        <div class="angle-item">
          <label>φ (azimuthal) <span id="phi-val">0.00°</span></label>
          <input type="range" id="phi-slider" min="0" max="359" value="0" step="0.5" oninput="onAngleChange()">
        </div>
      </div>
    </div>

    <div>
      <div class="section-label">Apply Gate</div>
      <div class="gate-grid">
        <button class="gate-btn h-gate" onclick="applyGate('H')">H</button>
        <button class="gate-btn x-gate" onclick="applyGate('X')">X</button>
        <button class="gate-btn x-gate" onclick="applyGate('Y')">Y</button>
        <button class="gate-btn x-gate" onclick="applyGate('Z')">Z</button>
        <button class="gate-btn" onclick="applyGate('S')">S</button>
        <button class="gate-btn" onclick="applyGate('T')">T</button>
        <button class="gate-btn special" onclick="applyGate('S†')">S†</button>
        <button class="gate-btn special" onclick="applyGate('T†')">T†</button>
      </div>
    </div>

    <div>
      <div class="section-label">Rotations</div>
      <div class="angle-item" style="margin-bottom:0.5rem">
        <label>angle <span id="rot-val">90.0°</span></label>
        <input type="range" id="rot-slider" min="1" max="360" value="90" step="1" oninput="updateRotVal()">
      </div>
      <div class="rotation-row">
        <select id="rot-axis">
          <option value="x">Rx — around X axis</option>
          <option value="y">Ry — around Y axis</option>
          <option value="z">Rz — around Z axis</option>
        </select>
        <button onclick="applyRotation()">Apply →</button>
      </div>
    </div>

    <div class="noise-section">
      <div class="section-label">Noise Channel</div>
      <select id="noise-type">
        <option value="depol">Depolarizing</option>
        <option value="amp">Amplitude Damping</option>
        <option value="phase">Phase Damping</option>
        <option value="bitflip">Bit Flip</option>
        <option value="phaseflip">Phase Flip</option>
      </select>
      <div class="angle-item">
        <label>strength <span id="noise-val">0.10</span></label>
        <input type="range" id="noise-slider" min="0" max="100" value="10" step="1" oninput="updateNoiseVal()">
      </div>
      <button onclick="applyNoise()">Apply Noise</button>
    </div>

    <div>
      <div class="section-label">Actions</div>
      <div class="action-row">
        <button class="action-btn measure" onclick="measure()">⊙ Measure</button>
        <button class="action-btn reset" onclick="resetState()">⟳ Reset</button>
      </div>
    </div>
  </div>

  <!-- CENTER -->
  <div class="panel-center">
    <div class="measurement-flash" id="mflash"></div>
    <canvas id="bloch-canvas" width="420" height="420"></canvas>
    <div class="state-display">
      <div class="ket-display" id="ket-display">|0⟩</div>
      <div id="state-sub">P(|0⟩) = 1.0000  ·  P(|1⟩) = 0.0000</div>
    </div>
  </div>

  <!-- RIGHT -->
  <div class="panel-right">
    <div>
      <div class="section-label">State Properties</div>
      <div class="state-card">
        <div class="state-row">
          <span class="label">Purity tr(ρ²)</span>
          <span class="value good" id="purity-val">1.0000</span>
        </div>
        <div class="state-row">
          <span class="label">State type</span>
          <span class="value good" id="state-type">Pure</span>
        </div>
        <div class="state-row">
          <span class="label">Von Neumann S</span>
          <span class="value" id="entropy-val">0.0000</span>
        </div>
        <div class="state-row">
          <span class="label">|Bloch vector|</span>
          <span class="value" id="bloch-len">1.0000</span>
        </div>
        <div class="state-row">
          <span class="label">ρ₀₀ (Re)</span>
          <span class="value" id="rho00">1.0000</span>
        </div>
        <div class="state-row">
          <span class="label">ρ₀₁ (|coherence|)</span>
          <span class="value" id="rho01">0.0000</span>
        </div>
      </div>
    </div>

    <div>
      <div class="section-label">Measurement Probs</div>
      <div class="prob-bars">
        <div class="prob-bar-item">
          <div class="prob-bar-label"><span>|0⟩</span><span id="p0-label">100.0%</span></div>
          <div class="prob-bar-track"><div class="prob-bar-fill zero" id="p0-bar" style="width:100%"></div></div>
        </div>
        <div class="prob-bar-item">
          <div class="prob-bar-label"><span>|1⟩</span><span id="p1-label">0.0%</span></div>
          <div class="prob-bar-track"><div class="prob-bar-fill one" id="p1-bar" style="width:0%"></div></div>
        </div>
      </div>
    </div>

    <div>
      <div class="section-label">Bloch Vector</div>
      <div class="bloch-readout">
        <div class="bloch-axis ax-x">
          <div class="axis-label">⟨X⟩</div>
          <div class="axis-val" id="bx-val">0.000</div>
        </div>
        <div class="bloch-axis ax-y">
          <div class="axis-label">⟨Y⟩</div>
          <div class="axis-val" id="by-val">0.000</div>
        </div>
        <div class="bloch-axis ax-z">
          <div class="axis-label">⟨Z⟩</div>
          <div class="axis-val" id="bz-val">1.000</div>
        </div>
      </div>
    </div>

    <div>
      <div class="section-label">Last Measurement</div>
      <div class="last-measure-box" id="measure-box">
        <div class="outcome" id="measure-outcome">0</div>
        <div>collapsed to |<span id="measure-state">0</span>⟩</div>
      </div>
      <div id="no-measure" style="font-size:0.65rem; color:var(--text-dim)">No measurement yet.</div>
    </div>

    <div>
      <div class="section-label">Operation History</div>
      <div class="history-list" id="history-list">
        <div class="history-entry">
          <span class="op">INIT</span>
          <span>|0⟩ state prepared</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════
//  QUANTUM STATE ENGINE (pure JS density matrix sim)
// ═══════════════════════════════════════════════════════

function c(re, im=0) { return {re, im}; }
function add(a,b) { return {re:a.re+b.re, im:a.im+b.im}; }
function mul(a,b) { return {re:a.re*b.re-a.im*b.im, im:a.re*b.im+a.im*b.re}; }
function conj(a) { return {re:a.re, im:-a.im}; }
function abs2(a) { return a.re*a.re + a.im*a.im; }
function absC(a) { return Math.sqrt(abs2(a)); }
function scale(s,a) { return {re:s*a.re, im:s*a.im}; }

// 2x2 complex matrix multiply: M = A @ B
function matMul(A, B) {
  return [
    [add(mul(A[0][0],B[0][0]), mul(A[0][1],B[1][0])),  add(mul(A[0][0],B[0][1]), mul(A[0][1],B[1][1]))],
    [add(mul(A[1][0],B[0][0]), mul(A[1][1],B[1][0])),  add(mul(A[1][0],B[0][1]), mul(A[1][1],B[1][1]))]
  ];
}

// M†
function dagMat(M) {
  return [
    [conj(M[0][0]), conj(M[1][0])],
    [conj(M[0][1]), conj(M[1][1])]
  ];
}

// ρ → U ρ U†
function applyU(rho, U) {
  const Ud = dagMat(U);
  return matMul(matMul(U, rho), Ud);
}

function kronSum(A, B, k=1) {
  // Kraus: rho → Σ K_k rho K_k†
  let result = [[c(0),c(0)],[c(0),c(0)]];
  for (let K of k) {
    const Kd = dagMat(K);
    const term = matMul(matMul(K, A), Kd);
    for (let i=0;i<2;i++) for (let j=0;j<2;j++) result[i][j] = add(result[i][j], term[i][j]);
  }
  return result;
}

function purity(rho) {
  // tr(rho^2)
  const rho2 = matMul(rho, rho);
  return rho2[0][0].re + rho2[1][1].re;
}

function vonNeumannEntropy(rho) {
  // Eigenvalues of 2x2 Hermitian: via discriminant
  const a = rho[0][0].re, d = rho[1][1].re;
  const bc2 = abs2(rho[0][1]);
  const disc = Math.sqrt(Math.max(0, ((a-d)/2)**2 + bc2));
  const mid = (a+d)/2;
  const e1 = mid + disc, e2 = mid - disc;
  let S = 0;
  if (e1 > 1e-12) S -= e1 * Math.log(e1);
  if (e2 > 1e-12) S -= e2 * Math.log(e2);
  return S;
}

function blochVector(rho) {
  // <X> = 2*Re(rho[0][1])
  // <Y> = 2*Im(rho[1][0])  = -2*Im(rho[0][1])
  // <Z> = rho[0][0] - rho[1][1]
  return {
    x: 2 * rho[0][1].re,
    y: -2 * rho[0][1].im,
    z: rho[0][0].re - rho[1][1].re
  };
}

// ── Gate Definitions ──────────────────────────────────
const ISQRT2 = 1/Math.sqrt(2);

function gateH() { return [[c(ISQRT2),c(ISQRT2)],[c(ISQRT2),c(-ISQRT2)]]; }
function gateX() { return [[c(0),c(1)],[c(1),c(0)]]; }
function gateY() { return [[c(0),c(0,-1)],[c(0,1),c(0)]]; }
function gateZ() { return [[c(1),c(0)],[c(0),c(-1)]]; }
function gateS() { return [[c(1),c(0)],[c(0),c(0,1)]]; }
function gateT() {
  const v = Math.SQRT1_2;
  return [[c(1),c(0)],[c(0),c(v,v)]];
}
function gateSdag() { return [[c(1),c(0)],[c(0),c(0,-1)]]; }
function gateTdag() {
  const v = Math.SQRT1_2;
  return [[c(1),c(0)],[c(0),c(v,-v)]];
}
function gateRx(t) {
  const ct = Math.cos(t/2), st = Math.sin(t/2);
  return [[c(ct),c(0,-st)],[c(0,-st),c(ct)]];
}
function gateRy(t) {
  const ct = Math.cos(t/2), st = Math.sin(t/2);
  return [[c(ct),c(-st)],[c(st),c(ct)]];
}
function gateRz(t) {
  return [[c(Math.cos(t/2), -Math.sin(t/2)), c(0)],[c(0), c(Math.cos(t/2), Math.sin(t/2))]];
}

// ── Noise Channels ────────────────────────────────────
function applyDepolarizing(rho, p) {
  const I = [[c(1),c(0)],[c(0),c(1)]];
  const X = gateX(), Y = gateY(), Z = gateZ();
  const k = [
    [[c(Math.sqrt(1-p)),c(0)],[c(0),c(Math.sqrt(1-p))]],
    [[c(0),c(Math.sqrt(p/3))],[c(Math.sqrt(p/3)),c(0)]],
    [[c(0),c(0,-Math.sqrt(p/3))],[c(0,Math.sqrt(p/3)),c(0)]],
    [[c(Math.sqrt(p/3)),c(0)],[c(0),c(-Math.sqrt(p/3))]],
  ];
  return kronSum(rho, null, k);
}

function applyAmplitudeDamping(rho, gamma) {
  const g = gamma;
  const K0 = [[c(1),c(0)],[c(0),c(Math.sqrt(1-g))]];
  const K1 = [[c(0),c(Math.sqrt(g))],[c(0),c(0)]];
  return kronSum(rho, null, [K0, K1]);
}

function applyPhaseDamping(rho, lam) {
  const K0 = [[c(1),c(0)],[c(0),c(Math.sqrt(1-lam))]];
  const K1 = [[c(0),c(0)],[c(0),c(Math.sqrt(lam))]];
  return kronSum(rho, null, [K0, K1]);
}

function applyBitFlip(rho, p) {
  const K0 = [[c(Math.sqrt(1-p)),c(0)],[c(0),c(Math.sqrt(1-p))]];
  const K1 = [[c(0),c(Math.sqrt(p))],[c(Math.sqrt(p)),c(0)]];
  return kronSum(rho, null, [K0, K1]);
}

function applyPhaseFlip(rho, p) {
  const K0 = [[c(Math.sqrt(1-p)),c(0)],[c(0),c(Math.sqrt(1-p))]];
  const K1 = [[c(Math.sqrt(p)),c(0)],[c(0),c(-Math.sqrt(p))]];
  return kronSum(rho, null, [K0, K1]);
}

// ─────────────────────────────────────────────────────
//  Global State
// ─────────────────────────────────────────────────────
let RHO = [[c(1),c(0)],[c(0),c(0)]]; // |0><0|
let currentLabel = '|0⟩';
let opHistory = [];
let rotAngle = Math.PI/2;
let cameraTheta = 0.4;
let cameraPhi = 0.6;
let isDragging = false;
let lastMouse = null;

// ─────────────────────────────────────────────────────
//  Preset States
// ─────────────────────────────────────────────────────
function setPreset(a, b, label) {
  // a,b can be numbers or {im: number} for imaginary
  let alpha, beta;
  if (typeof a === 'number') alpha = {re: a, im: 0};
  else alpha = {re: a.re || 0, im: a.im || 0};
  if (typeof b === 'number') beta = {re: b, im: 0};
  else beta = {re: b.re || 0, im: b.im || 0};

  // Normalize
  const norm = Math.sqrt(abs2(alpha) + abs2(beta));
  alpha = scale(1/norm, alpha);
  beta = scale(1/norm, beta);

  // ρ = |ψ><ψ|
  RHO = [
    [mul(alpha, conj(alpha)), mul(alpha, conj(beta))],
    [mul(beta, conj(alpha)),  mul(beta, conj(beta))]
  ];
  currentLabel = label;
  addHistory('INIT', label + ' prepared');
  updateAll();

  // sync sliders to bloch angles
  const bv = blochVector(RHO);
  const r = Math.sqrt(bv.x**2 + bv.y**2 + bv.z**2);
  if (r > 0.001) {
    const theta_deg = Math.acos(Math.min(1, Math.max(-1, bv.z/r))) * 180/Math.PI;
    const phi_deg = ((Math.atan2(bv.y, bv.x) * 180/Math.PI) + 360) % 360;
    document.getElementById('theta-slider').value = theta_deg;
    document.getElementById('phi-slider').value = phi_deg;
    document.getElementById('theta-val').textContent = theta_deg.toFixed(1) + '°';
    document.getElementById('phi-val').textContent = phi_deg.toFixed(1) + '°';
  }

  document.querySelectorAll('.state-btn').forEach(b => b.classList.remove('active'));
  event.currentTarget.classList.add('active');
}

function onAngleChange() {
  const theta = parseFloat(document.getElementById('theta-slider').value) * Math.PI / 180;
  const phi = parseFloat(document.getElementById('phi-slider').value) * Math.PI / 180;
  document.getElementById('theta-val').textContent = (theta*180/Math.PI).toFixed(1) + '°';
  document.getElementById('phi-val').textContent = (phi*180/Math.PI).toFixed(1) + '°';

  const alpha = c(Math.cos(theta/2));
  const betaRe = Math.sin(theta/2) * Math.cos(phi);
  const betaIm = Math.sin(theta/2) * Math.sin(phi);
  const beta = c(betaRe, betaIm);

  RHO = [
    [mul(alpha, conj(alpha)), mul(alpha, conj(beta))],
    [mul(beta, conj(alpha)),  mul(beta, conj(beta))]
  ];
  currentLabel = `θ=${(theta*180/Math.PI).toFixed(0)}° φ=${(phi*180/Math.PI).toFixed(0)}°`;
  updateAll();
}

function updateRotVal() {
  const deg = parseInt(document.getElementById('rot-slider').value);
  rotAngle = deg * Math.PI / 180;
  document.getElementById('rot-val').textContent = deg.toFixed(0) + '°';
}

function updateNoiseVal() {
  const v = parseInt(document.getElementById('noise-slider').value) / 100;
  document.getElementById('noise-val').textContent = v.toFixed(2);
}

// ─────────────────────────────────────────────────────
//  Gate Application
// ─────────────────────────────────────────────────────
const GATE_MAP = {
  'H': gateH, 'X': gateX, 'Y': gateY, 'Z': gateZ,
  'S': gateS, 'T': gateT, 'S†': gateSdag, 'T†': gateTdag
};

function applyGate(name) {
  const gate = GATE_MAP[name]();
  RHO = applyU(RHO, gate);
  addHistory(name, getBlochStr());
  updateAll();
  animateGatePulse();
}

function applyRotation() {
  const axis = document.getElementById('rot-axis').value;
  let gate;
  if (axis === 'x') gate = gateRx(rotAngle);
  else if (axis === 'y') gate = gateRy(rotAngle);
  else gate = gateRz(rotAngle);
  RHO = applyU(RHO, gate);
  const name = `R${axis.toUpperCase()}(${(rotAngle*180/Math.PI).toFixed(0)}°)`;
  addHistory(name, getBlochStr());
  updateAll();
}

function applyNoise() {
  const type = document.getElementById('noise-type').value;
  const p = parseInt(document.getElementById('noise-slider').value) / 100;
  if (type === 'depol') RHO = applyDepolarizing(RHO, p);
  else if (type === 'amp') RHO = applyAmplitudeDamping(RHO, p);
  else if (type === 'phase') RHO = applyPhaseDamping(RHO, p);
  else if (type === 'bitflip') RHO = applyBitFlip(RHO, p);
  else if (type === 'phaseflip') RHO = applyPhaseFlip(RHO, p);
  const labels = {depol:'Depol', amp:'AmpDamp', phase:'PhaseDamp', bitflip:'BitFlip', phaseflip:'PhaseFlip'};
  addHistory(`${labels[type]}(${p.toFixed(2)})`, `purity=${purity(RHO).toFixed(3)}`, true);
  updateAll();
}

function measure() {
  const p0 = RHO[0][0].re;
  const outcome = Math.random() < p0 ? 0 : 1;

  // Collapse
  if (outcome === 0) {
    RHO = [[c(1),c(0)],[c(0),c(0)]];
  } else {
    RHO = [[c(0),c(0)],[c(0),c(1)]];
  }

  // Flash
  const flash = document.getElementById('mflash');
  flash.classList.add('active');
  setTimeout(() => flash.classList.remove('active'), 200);

  // Show result
  document.getElementById('measure-box').classList.add('show');
  document.getElementById('no-measure').style.display = 'none';
  document.getElementById('measure-outcome').textContent = outcome;
  document.getElementById('measure-state').textContent = outcome;

  addHistory('MEASURE', `→ |${outcome}⟩  (was P=${(outcome===0?p0:1-p0).toFixed(3)})`, false, true);
  updateAll();
}

function resetState() {
  RHO = [[c(1),c(0)],[c(0),c(0)]];
  currentLabel = '|0⟩';
  document.getElementById('measure-box').classList.remove('show');
  document.getElementById('no-measure').style.display = 'block';
  document.getElementById('theta-slider').value = 0;
  document.getElementById('phi-slider').value = 0;
  document.getElementById('theta-val').textContent = '0.0°';
  document.getElementById('phi-val').textContent = '0.0°';
  document.querySelectorAll('.state-btn').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.state-btn')[0].classList.add('active');
  opHistory = [];
  document.getElementById('history-list').innerHTML = '';
  addHistory('RESET', '|0⟩ state prepared');
  updateAll();
}

function getBlochStr() {
  const bv = blochVector(RHO);
  return `(${bv.x.toFixed(2)}, ${bv.y.toFixed(2)}, ${bv.z.toFixed(2)})`;
}

// ─────────────────────────────────────────────────────
//  UI Updates
// ─────────────────────────────────────────────────────
function updateAll() {
  const p0 = Math.max(0, Math.min(1, RHO[0][0].re));
  const p1 = Math.max(0, Math.min(1, RHO[1][1].re));
  const bv = blochVector(RHO);
  const pur = purity(RHO);
  const ent = vonNeumannEntropy(RHO);
  const blochLen = Math.sqrt(bv.x**2 + bv.y**2 + bv.z**2);

  // Probs
  document.getElementById('p0-bar').style.width = (p0*100).toFixed(1) + '%';
  document.getElementById('p1-bar').style.width = (p1*100).toFixed(1) + '%';
  document.getElementById('p0-label').textContent = (p0*100).toFixed(1) + '%';
  document.getElementById('p1-label').textContent = (p1*100).toFixed(1) + '%';

  // Bloch
  document.getElementById('bx-val').textContent = bv.x.toFixed(3);
  document.getElementById('by-val').textContent = bv.y.toFixed(3);
  document.getElementById('bz-val').textContent = bv.z.toFixed(3);
  document.getElementById('bloch-len').textContent = blochLen.toFixed(4);

  // State props
  document.getElementById('purity-val').textContent = pur.toFixed(4);
  document.getElementById('purity-val').className = 'value ' + (pur > 0.99 ? 'good' : 'warn');
  document.getElementById('state-type').textContent = pur > 0.99 ? 'Pure' : 'Mixed';
  document.getElementById('state-type').className = 'value ' + (pur > 0.99 ? 'good' : 'warn');
  document.getElementById('entropy-val').textContent = ent.toFixed(4);
  document.getElementById('rho00').textContent = RHO[0][0].re.toFixed(4);
  document.getElementById('rho01').textContent = absC(RHO[0][1]).toFixed(4);

  // Ket display
  document.getElementById('ket-display').textContent = currentLabel;
  document.getElementById('state-sub').textContent =
    `P(|0⟩) = ${p0.toFixed(4)}  ·  P(|1⟩) = ${p1.toFixed(4)}`;

  drawBloch();
}

function addHistory(op, detail, isNoise=false, isMeasure=false) {
  opHistory.push({op, detail, isNoise, isMeasure});
  const list = document.getElementById('history-list');
  const entry = document.createElement('div');
  entry.className = 'history-entry' + (isMeasure ? ' measure-entry' : '');
  entry.innerHTML = `<span class="op">${op}</span><span>${detail}</span>`;
  list.appendChild(entry);
  list.scrollTop = list.scrollHeight;
}

function animateGatePulse() {
  const canvas = document.getElementById('bloch-canvas');
  canvas.style.filter = 'brightness(1.3) drop-shadow(0 0 12px #00e5ff)';
  setTimeout(() => canvas.style.filter = '', 200);
}

// ─────────────────────────────────────────────────────
//  Bloch Sphere Renderer
// ─────────────────────────────────────────────────────
const canvas = document.getElementById('bloch-canvas');
const ctx = canvas.getContext('2d');

function project(x, y, z) {
  // Rotate by camera angles
  const ct = Math.cos(cameraTheta), st = Math.sin(cameraTheta);
  const cp = Math.cos(cameraPhi), sp = Math.sin(cameraPhi);
  // Rotate around Y then X
  const x1 = x*cp + z*sp;
  const y1 = y;
  const z1 = -x*sp + z*cp;
  const x2 = x1;
  const y2 = y1*ct - z1*st;
  const z2 = y1*st + z1*ct;

  const fov = 3.5;
  const scale = 150 / (fov - z2 * 0.3);
  return {
    px: 210 + x2 * scale,
    py: 210 - y2 * scale,
    depth: z2
  };
}

function drawLine3D(x1,y1,z1,x2,y2,z2,color,width=1,dash=[]) {
  const p1 = project(x1,y1,z1), p2 = project(x2,y2,z2);
  ctx.beginPath();
  ctx.setLineDash(dash);
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.moveTo(p1.px, p1.py);
  ctx.lineTo(p2.px, p2.py);
  ctx.stroke();
  ctx.setLineDash([]);
}

function drawBloch() {
  ctx.clearRect(0, 0, 420, 420);

  // Background glow
  const grd = ctx.createRadialGradient(210, 210, 10, 210, 210, 180);
  grd.addColorStop(0, 'rgba(0,229,255,0.03)');
  grd.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, 420, 420);

  const N = 40;

  // Draw sphere wireframe
  // Latitude circles
  for (let i = 1; i < 6; i++) {
    const lat = (i/6) * Math.PI;
    const r = Math.sin(lat);
    const zc = Math.cos(lat);
    const pts = [];
    for (let j = 0; j <= N; j++) {
      const lon = (j/N) * 2 * Math.PI;
      pts.push(project(r*Math.cos(lon), zc, r*Math.sin(lon)));
    }
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(26,40,69,0.8)';
    ctx.lineWidth = 0.5;
    ctx.moveTo(pts[0].px, pts[0].py);
    for (let p of pts.slice(1)) ctx.lineTo(p.px, p.py);
    ctx.stroke();
  }

  // Longitude circles (meridians)
  for (let i = 0; i < 8; i++) {
    const lon = (i/8) * Math.PI;
    const pts = [];
    for (let j = 0; j <= N; j++) {
      const lat = (j/N) * Math.PI;
      pts.push(project(Math.sin(lat)*Math.cos(lon), Math.cos(lat), Math.sin(lat)*Math.sin(lon)));
      pts.push(project(-Math.sin(lat)*Math.cos(lon), -Math.cos(lat), -Math.sin(lat)*Math.sin(lon)));
    }
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(26,40,69,0.8)';
    ctx.lineWidth = 0.5;
    let first = true;
    for (let p of pts) {
      if (first) { ctx.moveTo(p.px, p.py); first = false; }
      else ctx.lineTo(p.px, p.py);
    }
    ctx.stroke();
  }

  // Equator highlight
  {
    const pts = [];
    for (let j = 0; j <= N*2; j++) {
      const lon = (j/(N*2)) * 2 * Math.PI;
      pts.push(project(Math.cos(lon), 0, Math.sin(lon)));
    }
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(0,229,255,0.2)';
    ctx.lineWidth = 1;
    ctx.moveTo(pts[0].px, pts[0].py);
    for (let p of pts.slice(1)) ctx.lineTo(p.px, p.py);
    ctx.stroke();
  }

  // Axes
  const axisLen = 1.25;
  const axes = [
    {from:[0,0,0], to:[axisLen,0,0], color:'rgba(255,45,109,0.6)', label:'+X'},
    {from:[0,0,0], to:[0,axisLen,0], color:'rgba(0,255,136,0.6)', label:'+Y'},
    {from:[0,0,0], to:[0,0,axisLen], color:'rgba(0,229,255,0.6)', label:'+Z'},
    {from:[0,0,0], to:[-axisLen,0,0], color:'rgba(255,45,109,0.2)', dash:[4,4]},
    {from:[0,0,0], to:[0,-axisLen,0], color:'rgba(0,255,136,0.2)', dash:[4,4]},
    {from:[0,0,0], to:[0,0,-axisLen], color:'rgba(0,229,255,0.2)', dash:[4,4]},
  ];

  for (const ax of axes) {
    drawLine3D(...ax.from, ...ax.to, ax.color, 1, ax.dash || []);
    if (ax.label) {
      const p = project(...ax.to);
      ctx.fillStyle = ax.color;
      ctx.font = '700 11px Space Mono';
      ctx.fillText(ax.label, p.px + 4, p.py + 4);
    }
  }

  // Pole labels
  const north = project(0, 1.35, 0);
  const south = project(0, -1.35, 0);
  ctx.fillStyle = 'rgba(0,229,255,0.5)';
  ctx.font = '10px Space Mono';
  ctx.fillText('|0⟩', north.px - 8, north.py);
  ctx.fillText('|1⟩', south.px - 8, south.py);

  // Bloch vector
  const bv = blochVector(RHO);
  const len = Math.sqrt(bv.x**2 + bv.y**2 + bv.z**2);
  const pur = purity(RHO);

  // Draw projection lines (dashed)
  drawLine3D(bv.x, bv.y, bv.z, bv.x, 0, bv.z, 'rgba(0,229,255,0.2)', 1, [3,3]);
  drawLine3D(bv.x, 0, bv.z, 0, 0, 0, 'rgba(0,229,255,0.15)', 1, [3,3]);

  // Arrow body
  const tip = project(bv.x, bv.y, bv.z);
  const origin = project(0, 0, 0);
  const arrowColor = pur > 0.99 ? '#00e5ff' : '#ff6b35';
  const glowColor = pur > 0.99 ? 'rgba(0,229,255,0.3)' : 'rgba(255,107,53,0.3)';

  ctx.beginPath();
  ctx.shadowBlur = 20;
  ctx.shadowColor = glowColor;
  ctx.strokeStyle = arrowColor;
  ctx.lineWidth = 2.5;
  ctx.moveTo(origin.px, origin.py);
  ctx.lineTo(tip.px, tip.py);
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Arrow head
  const dx = tip.px - origin.px, dy = tip.py - origin.py;
  const angle = Math.atan2(dy, dx);
  const headLen = 10;
  ctx.beginPath();
  ctx.fillStyle = arrowColor;
  ctx.moveTo(tip.px, tip.py);
  ctx.lineTo(tip.px - headLen*Math.cos(angle-0.4), tip.py - headLen*Math.sin(angle-0.4));
  ctx.lineTo(tip.px - headLen*Math.cos(angle+0.4), tip.py - headLen*Math.sin(angle+0.4));
  ctx.closePath();
  ctx.fill();

  // State point glow
  ctx.beginPath();
  ctx.arc(tip.px, tip.py, 5, 0, Math.PI*2);
  ctx.fillStyle = arrowColor;
  ctx.shadowBlur = 15;
  ctx.shadowColor = arrowColor;
  ctx.fill();
  ctx.shadowBlur = 0;

  // Origin dot
  const orig = project(0,0,0);
  ctx.beginPath();
  ctx.arc(orig.px, orig.py, 3, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.fill();
}

// ─────────────────────────────────────────────────────
//  Camera Drag Controls
// ─────────────────────────────────────────────────────
canvas.addEventListener('mousedown', e => {
  isDragging = true;
  lastMouse = {x: e.clientX, y: e.clientY};
});

window.addEventListener('mousemove', e => {
  if (!isDragging) return;
  const dx = e.clientX - lastMouse.x;
  const dy = e.clientY - lastMouse.y;
  cameraPhi += dx * 0.01;
  cameraTheta += dy * 0.01;
  cameraTheta = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraTheta));
  lastMouse = {x: e.clientX, y: e.clientY};
  drawBloch();
});

window.addEventListener('mouseup', () => isDragging = false);

canvas.addEventListener('touchstart', e => {
  isDragging = true;
  lastMouse = {x: e.touches[0].clientX, y: e.touches[0].clientY};
});

canvas.addEventListener('touchmove', e => {
  if (!isDragging) return;
  const dx = e.touches[0].clientX - lastMouse.x;
  const dy = e.touches[0].clientY - lastMouse.y;
  cameraPhi += dx * 0.01;
  cameraTheta += dy * 0.01;
  cameraTheta = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraTheta));
  lastMouse = {x: e.touches[0].clientX, y: e.touches[0].clientY};
  drawBloch();
  e.preventDefault();
}, {passive: false});

// ─────────────────────────────────────────────────────
//  Init
// ─────────────────────────────────────────────────────
updateAll();
</script>
</body>
</html>
